# os
# 운영체제
- 컴퓨터 시스템의 자원들을 효율적으로 관리
- 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
- 종류 : Windows, UNIX, LINUX, MacOS, MS-DOS

# 운영체제의 목적
- 처리능력 향상
- 사용 가능도 향상
- 신뢰도 향상
- 반환시간 단축

# 운영체제의 기능
- 프로세서, 기억장치, 입출력 장치, 파일 및 정보등의 자원 관리
- 자원의 스케줄링 기능 제공
- 사용자와 시스템간의 편리한 인터페이스 제공
- 하드웨어와 네트워크를 관리 및 제어
- 데이터 관리 및 데이터와 자원의 공유기능 제공

# 운영체제의 종류
- Windows : 1990년대 마이크로 소프트 사가 개발한 운영체제 
    - 특징 : 그래픽 사용자 인터페이스, 선점형 멀티태스킹, PnP, OLE, 255자의 긴 파일명, Single-User 시스템
- Unix : 1960년대 AT&T벨 연구소, MIT, General Electiric 공동 개발
    - 특징 : 시분할 시스템을 위한 대화식 운영체제, 개방형 시스템, C언어로 작성, 이식성과 호환성이 높음, 다중 사용자와 다중 작업 지원, 트리 구조의 파 일 시스템 
    - 구성 : 커널, 쉘, 유틸리티프로그램 
- Linux : 리누스 토발즈가 UNIX를 기반으로 개발 
    - 특징 : 코드 무료 공개, 다양한 플랫폼에서 사용, 재배포 가능, UNIX와 완벽하게 호환되고 특징이 동일. 
- MacOS :애플사가 UNIX를 기반으로 개발 
    - 특징 : 애플 사 제품만 가능, 드라이버 설치와 삭제의 과정이 단순함. 
- Android : 구글에서 Linux 커널 기반으로 개발. (모바일) 
    - 특징 : 개방형 소프트웨어, 자바와 코틀린으로 작성, 휴대용 장치에서 주로 사용 
- iOS : 애플사가 UNIX를 기반으로 개발. (모바일) 
    - 특징 : 애플사 제품만 가능. 

## 운영체제의 핵심 기능
- 메모리 관리 : 프로그램 실행이 종료될 때까지 메모리를 가용한 상태로 유지 및 관리하는 기능 메모리가 꽉 차게 되면 시스템의 속도가 느려지고 때로는 시스템이 멈춤
- 프로세스 관리 : 일시 중지 및 재실행, 동기화, 교착상태 처리, 프로세스 생성 및 삭제

### 메모리 관리 기법
- 반입 기법 : 주기억장치에 적재할 다음 프로세스의 반입 시기를 결정(요구, 예상)
- 배치 기법 : 프로세스를 주기억장치의 어느 위치에 저장할 것인지 결정(최초, 최적, 최악)
- 할당 기법 : 프로세스를 주기억장치에 어떤 방법으로 할당할 것인지 결정(연속, 분산)
- 교체 기법 : 주기억장치에 있는 어떤 프로세스를 제거할 것인지를 결정(Swap In/Out, FIFO, Optimal, LRU, LFU, 시계 알고리즘, MFU)

### 메모리 배치 기법
- 최초적합(First-fit)
    - 가용공간 중 첫 번째 분할에 할당하는 방식
    - 가용공간이 100, 200, 300 이렇게 있고 프로세스 A 150, B 210 적재시 다음과 같이 적재.

| 100 | 200 | 300 |
| --- | --- | --- |
|     | 프로세스 A | 프로세스 B |
- 최적적합(Best-fit)
    - 가용공간 중 가장 크기가 비슷한 공간을 선택하여 할당하는 방식
    - 가용공간이 100, 200, 300 이렇게 있고 프로세스 A 250, B 190 적재시 다음과 같이 적재.

| 100 | 200 | 300 |
| --- | --- | --- |
|     | 프로세스 B | 프로세스 A |
- 최악적합(Worst-fit)
    - 가용공간 중 가장 크기가 큰 공간에 할당하는 방식
    - 가용공간이 100, 200, 300 이렇게 있고 프로세스 A 180, B 120 적재시 다음과 같이 적재.

| 100 | 200 | 300 |
| --- | --- | --- |
|     | 프로세스 B | 프로세스 A |

## 프로세스 상태
- 생성 상태 : 사용자에 의해 생성된 상태
- 준비 상태 : CPU를 할당 받을 수 있는 상태
- 실행 상태 : 프로세스가 CPU를 할당받아 동작중인 상태
- 대기 상태 : 프로세스 실행 중 입출력 처리 등으로 인해 CPU를 양도하고 입출력 처리가 완료까지 대기 리스트에서 기다리는 상태
- 완료 상태 : 프로세스가 CPU를 할당받아 주어진 시간 내에 완전히 수행을 종료한 상태.

## 프로세스 상태 전이
- 디스패치 : 준비 상태에 있는 여러 프로세스 중 실행될 프로세스를 선정하여 CPU를 할당
- 타이머 런 아웃 : CPU를 할당받은 프로세스는 지정된 시간이 초과되면 스케줄러에 의해 PCB 저장, CPU 반납 후 다시 준비 상태로 전이
- 블록 : 실행 상태에 있는 프로세스는 지정된 할당시간을 초과하기 전에 입출력이나 기타 사건이 발생하면 CPU를 스스로 반납하고 입출력이 완료될 때까지 대기 상태로 전이
- 웨이크 업 : 어느 순간에 입출력이 종료되면 대기 상태의 프로세스에게 입출력 종료 사실을 wait & signal등에 의해 알려주고, 준비 상태로 전이

## 프로세스 스케줄링
- CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업
- 처리율과 CPU 이용률을 증가 / 오버헤드, 응답시간, 반환시간, 대기시간을 최소화하기 위한 기법
- 적합하게 실행되도록 스케줄링에 의해 프로세스 사이에서 CPU 교체가 일어남.
- 장기, 중기, 단기 스케줄러가 존재.

### 선점형 스케줄링
- 하나의 프로세스가 CPU를 차지하고 있을 때, 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식
- 장점 : 비교적 빠른 응답, 대화식 시분할 시스템 적합
- 단점 : 높은 우선순위 프로세스들이 들어오는 경우 오버헤드 초래
- 알고리즘 : 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐
- 활용 : 실시간 응답 환경, Deadline 응답 환경

### 비선점형 스케줄링
- 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식
- 장점 : 응답시간 예상이 용이, 모든 프로세스에 대한 요구를 공정하게 처리
- 단점 : 짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기
- 알고리즘 : 우선순위, 기한부, HRN, FCFS, SJF
- 활용 : 처리시간 편차가 적은 특정 프로세스 환경

### 선점형 스케줄링 알고리즘
- 라운드 로빈 : 균등한 CPU 점유시간, 시분할 시스템을 사용
- SRT : 짧은 수행시간 프로세스 우선 수행
- 다단계 큐 : 독립된 스케줄링 큐
- 다단계 피드백 큐  : 큐마다 다른 시간 할당량, 마지막단계는 라운드 로빈 방식 처리

### 비선점형 스케줄링 알고리즘
- 우선순위 : 주요 긴급 프로세스에 대한 우선 처리 / 설정, 자원 상황 등에 따른 우선순위 선정
- 기한부 : 요청에 명시된 시간 내 처리를 보장
- HRN : 기아 현상 최소화 기법(에이징)
- FCFS : 도착한 순서대로 처리
- SJF : 기아 현상 방생 가능성

## 스케줄링 알고리즘 계산 방법
★ FIFO 스케줄링
| 프로세스 | 도착 시간 | 서비스 시간 |
| --- | --- | --- |
| P1 | 0  | 3 |
| P2 | 1 | 7 |
| P3 | 3 | 2 |
| P4 | 5 | 5 |
- P1은 0시~ 3시까지 실행중.
- P2는 1시에 도착했지만 P1가 먼저와서 끝난 후 실행.  3~10시에 실행중.
- P3는 3시에 도착했지만 P2가 먼저와서 끝난 후 실행. 10~12시에 실행중.
- P4는 5시에 도착했지만 P2가 실행중이고 P3보다 늦게왔기 때문에 12~17에 실행됨.

※ 반환시간을 구한다면(종료시간 - 도착시간)
- P1은 3시간
- P2는 오는데 걸린 1시간 제외 9시간
- P3는 오는데 걸린 3시간 제외 9시간
- P4는 오는데 걸린 5시간 제외 12시간

※ 대기시간을 구한다면(반환시간 - 서비스시간)
- P1은 0시간
- P2는 P1이 종료될때까지 대기한 2시간
- P3는 P2이 종료될때까지 대기한 7시간
- P4는 P3이 종료될때까지 대기한 7시간

★ SJF 스케줄링
| 프로세스 | 도착 시간 | 서비스 시간 |
| --- | --- | --- |
| P1 | 0  | 3 |
| P2 | 1 | 7 |
| P3 | 3 | 2 |
| P4 | 5 | 5 |
- P1은 0시~ 3시까지 실행중.
- P2는 1시에 도착했지만 P3와 P4보다 서비스 시간이 길어서 마지막 10~17에 실행.
- P3는 3시에 도착했지만 P2와 P4보다 서비스 시간이 짧아서 3~5에 실행.
- P4는 5시에 도착했지만 P2보다 서비스 시간이 짧아서 5~10에 실행.

※ 반환시간을 구한다면(종료시간 - 도착시간)
- P1은 3시간
- P2는 오는데 걸린 1시간 제외 16시간
- P3는 오는데 걸린 3시간 제외 2시간
- P4는 오는데 걸린 5시간 제외 5시간

※ 대기시간을 구한다면(반환시간 - 서비스시간)
- P1은 0시간
- P2는 모두 종료될때까지 대기한 9시간
- P3는 도착하자마자 실행되서 0시간
- P4는 도착하자마자 실행되서 0시간

★ RR 스케줄링
- 시간 할당량이 2

| 프로세스 | 도착 시간 | 서비스 시간 |
| --- | --- | --- |
| P1 | 0  | 3 |
| P2 | 1 | 7 |
| P3 | 3 | 2 |
| P4 | 5 | 5 |
- 진행 도중 다른 프로세스가 도착하면 시간할당량 만큼만 진행후 남은 작업은 다음 프로세스가 끝난 후 작업.

※ 반환시간을 구한다면(종료시간 - 도착시간)
- P1은 5시간
- P2는 오는데 걸린 1시간 제외 15시간
- P3는 오는데 걸린 3시간 제외 4시간
- P4는 오는데 걸린 5시간 제외 12시간

※ 대기시간을 구한다면(반환시간 - 서비스시간)
- P1은 2시간
- P2는 모두 종료될때까지 대기한 8시간
- P3는 도착하자마자 실행되서 2시간
- P4는 도착하자마자 실행되서 7시간

★ SRT 스케줄링
- 시간 할당량이 2

| 프로세스 | 도착 시간 | 서비스 시간 |
| --- | --- | --- |
| P1 | 0  | 3 |
| P2 | 2 | 6 |
| P3 | 4 | 4 |
| P4 | 8 | 2 |
- 진행 도중 다른 프로세스가 도착하면 남은 서비스 시간이 짧은쪽을 먼저 진행 하고 진행중인 프로세스는 뒤로 넘겨버림.

※ 반환시간을 구한다면(종료시간 - 도착시간)
- P1은 3시간
- P2는 오는데 걸린 2시간 제외 13시간
- P3는 오는데 걸린 4시간 제외 4시간
- P4는 오는데 걸린 8시간 제외 2시간

※ 대기시간을 구한다면(반환시간 - 서비스시간)
- P1은 도착하자마자 실행되서 0시간
- P2는 가장 마지막에 끝나서 7시간
- P3는 도착하자마자 실행되서 0시간
- P4는 도착하자마자 실행되서 0시간

## 프로세스 관리 - 교착상태
- 교착상태 - 다중프로세싱 환경에서 2개 이상의 프로세스가 특정 자원 할당을 무한정 대기하는 상태.
- 발생 조건
    - 상호 배제 : 프로세스가 자원을 배타적으로 점유하여 다른 프로세스가 그 자원을 사용할 수 없는 상태
    - 점유와 대기 : 한 프로세스가 자원을 점유하고 있으면서 또 다른 자원을 요청하여 대기하고 있는 상태
    - 비선점 : 한 프로세스가 점유한 자원에 대해 다른 프로세스가 선점할 수 없고, 오직 점유한 프로세스만이 해제 가능한 상태
    - 환형 대기 : 2개 이상의 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성한 상태
- 해결 방법
    - 예방 : 점유 자원 해제 후 새 자원 요청
    - 회피 : 은행가 알고리즘, Wound-Wait, Wait-Die
    - 발견 : 자원할당 그래프, Wait for Graph
    - 복구 : 프로세스 Kill, 자원선점

### 가상화
- 물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술.
- 대부분의 서버는 용량의 20% 정도만을 사용하는데, 가상화를 통해 서버의 가동률을 60% ~ 70% 이상으로 올릴 수 있음.
- 플랫폼 가상화 : 하드웨어 플랫폼 위에서 실행되는 호스트 프로그램이 게스트 프로그램을 만들어 마치 독립된 환경을 만들어 낸 것처럼 보여주는 기법
- 리소스 가상화 : 게스트 소프트웨어 위에서 사용자는 독립된 하드웨어에서 소프트웨어가 실행되는 것처럼 활용하는 기법

### 가상화 기술요소
- 컴퓨팅 가상화 : 물리적으로 컴퓨터 리소스를 가상화하여 논리적 단위로 리소스를 활용할 수 있도록 하는 기술
- 스토리지 가상화 : 스토리지와 서버 사이에 소프트웨어/하드웨어 계층을 추가하여 스토리지를 논리적으로 제어 및 활용할 수 있도록 하는 기술
- I/O 가상화 : 서버와 I/O 디바이스 사이에 위치하는 미들웨어 계층으로, 서버의 I/O 자원을 물리적으로 분리하고 케이블과 스위치 구성을 단순화하여 효율적인 연결을 지원하는 기술
- 컨테이너 : 컨테이너화된 애플리케이션들이 단일 운영체제상에서 실행되도록 해주는 기술
- 분산처리 기술 : 여러 대의 컴퓨터 계산 및 저장능력을 이용하여 커다란 계산문제나 대용량의 데이터를 처리하고 저장하는 기술
- 네트워크 가상화 기술 : 물리적으로 떨어져 있는 다양한 장비들을 연결하기 위한 수단으로 중계장치의 가상화를 통한 가상 네트워크를 지원하는 기술

### 클라우드 컴퓨팅
- 인터넷을 통해 가상화된 컴퓨터 시스템 리소스(IT 리소스)를 제공하고, 정보를 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터로 처리하는 기술
- 사설 클라우드 : 기업 또는 조직 내부에서 보유하고 있는 컴퓨팅 자원을 사용하여 내부에 구축되어 운영되는 클라우드
- 공용 클라우드 : 클라우드 서비스 제공 업체에서 다중 사용자를 위한 컴퓨팅 자원 서비스를 제공하는 클라우드
- 하이브리드 클라우드 : 기업 또는 조직 내부 자원을 이용한 사설 클라우드와 공용 클라우드를 모두 사용하는 클라우드

### 클라우드 컴퓨팅 유형
- 인프라형 서비스 : 서버, 스토리지 같은 시스템 자원을 클라우드로 제공하는 서비스
- 플랫폼형 서비스 : 인프라를 생성, 관리하는 복잡함 없이 애플리케이션을 개발, 실행, 관리할 수 있게 하는 플랫폼을 제공하는 서비스
- 소프트웨어형 서비스 : 소프트웨어 및 관련 데이터는 중앙에 호스팅되고 사용자는 웹 브라우저 등의 클라이언트를 통해 접속하여 소프트웨어를 서비스 형태로 이용하는 서비
